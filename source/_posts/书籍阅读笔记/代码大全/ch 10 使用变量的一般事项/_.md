# ch 10 使用变量的一般事项

> 你应该把每个变量定义成：只对 { 需要看到它的、最小范围的 }代码段  可见

* 了解数据类型的种类
  * 参考书籍
  * 测试


* 语言的隐式变量声明很危险

  * 解决办法

## 变量初始化

* 问题所在
* 建议
  * 不要扎堆
  * 就近原则
    * 在首次使用时的地方，声明和初始化
  * 使用计数器前，检查是否已经重置
  * 检查某些循环中的值是否需要重新初始化
    * 如果需要重新初始化，检查是否已经放进循环中了
  * 检查参数的合法性
    * 类型检查这些大部分语言都有了
    * 或许我们这里说的是其他种类


## 作用域

* 攻击窗口

  * 一个变量在引用点间的空白

  * > ```python
    > a = 'first use'
    > b = ''
    > # ...
    > foo(a)
    > ```
    >
    > a 的使用在 第一行和最后一行，中间的“空白”就是攻击窗口

  * 随着时间流逝，可能其他代码会插入到“易受攻击窗口”，更改变量 a 的所期望的值，导致程序行为发生改变


* 使变量引用局部化
  * 这里“变量引用”的意思大概就是“使用变量”，局部化的意思就是集中到一起于一个地方
  * 跨度、平均跨度
    * 某个变量在代码中的集中（分散）程度
  * 通俗的意思就是，对某个变量，对他进行的操作、使用，集中到一个地方，一气呵成，这样阅读时目光就不需要跳来跳去
* 尽可能缩短变量的“存活时间”
  * 存活时间是指一个变量存在期间所跨越的语句总数。由引用他的第一条语句和引用他的最后一条语句之间的距离决定

#### Minimizing 作用域的一般原则

* 变量的初始化应该尽量接近*变量第一次使用*的地方
  * 衍生规则
    * 循环变量：在靠近循环体的地方初始化，而不是在子程序一开始就初始化
    * 直到变量即将被使用再为其赋值（也就是赋值的变量应该尽快使用，减少攻击窗口）
* 把相关语句放在一起
  * 例子
  * 衍生规则
    * 可以把这些相关语句提取成单独的子程序
      * 这也是一个检测方法，因为只有变量的作用域够小，才容易集中提取
* 一开始时选择作用域时，tend to 选择最小所需的作用域
  * 不应该选择比较宽泛的作用域，想着以后能缩小，因为去缩减一个已有的大作用域，比去扩展一个小作用域，要困难得多
  * 顺序：
    * $$循环变量<子程序<类的 private 变量<类的 protected 变量<对 package 可见<global$$

> 一句话总结：变量引用点局部化、变量存活时间缩短

## 持续性

* 问题
  * 数据的持续性和变量的生命期不匹配
    * 变量和数据好比冰箱里的牛奶，不匹配时，变量声称的保质期过了（甚至是因为你搞错了保质期），数据就有可能已经发酸了
    * 即：有时变量的数值已经不是你想要的那个了，但你不知道，还以为用对了变量
* 解决
  * 加入调试代码 或者 `断言` 来检查关键变量，看取值是否合理
    * 何谓调试代码？
  * 抛弃变量时，用“不合理的值”去赋值
    * 如 null
    * 这样就能识别出来了，不会误打误撞让你糊涂
  * 假定数据没有持续性
    * ？？
  * 养成习惯：使用数据前，一起完成声明和初始化
    * 如果声明的位置和初始化位置相距甚远，要注意

## 绑定时间

简单来说，就是变量和他的值在什么时候绑定在一起

有如下时间（灵活性从小到大，复杂度从小到大）：

* 编码时
  * 编码时就写死变量的值，如果要更改，只能在代码中改
* 编译时
  * 使用具名常量，具体的值放在一处集中，编译时编译器会替换
  * 增加可读性，替换时也方便（改动一处即可）
* 加载时
  * 从外部数据源读取数据
  * 修改程序时不需改动代码，从外部修改配置文件就可以
* 对象实例化时
  * 每次创建窗体时都读取一次数据
* 即时
  * 每次窗体重绘时都先读取一次数据

> ![Snip20170713_50](Snip20170713_50.png)

## 控制结构

基本元素就 3 种：顺序、选择、迭代

## 为变量指定单一用途

* 每个变量只用于一种用途

  * 衍生

    * 不要在多个场合使用同一个“临时”变量，如 temp，那样毫无帮助

      * 例子

    * 避免变量有隐含含义

      * 如这种混淆的使用：pageCount 的值一般表示纸张数量，但有错误时，给他赋值 -1；（在这种情况下，整数类型客串了布尔类型的作用！）

      * > 使用两个变量来保存两种信息，会提高清晰度；没人会吝惜多用的那一点存储空间

* 确保使用了所有已声明的变量

  * 有些编译器会提示
  * 研究表明，未引用的变量数量和错误率呈正相关……

## 更清晰的术语加长

* 攻击窗口：“因为某变量的分散，使其容易受到（其他代码插入等）攻击而改变的空白区域”
  * 空白是指对这一变量来说
* 变量的存活时间：在源代码中，对一个变量，引用他的第一条语句和引用他的最后一条语句之间的代码行数的多少
* 持续性：

## 问题

* 在所写的 smzdm 监测脚本中，像 block_list 这些目前是 global，不知道要如何改善
  * 知道应该按这里的规则去改，但很难改