## 子程序

子程序（`routine`）是为实现一个特定的目的而编写的一个可被调用的方法（`method`）或过程（`procedure`）



## 在子程序层上设计

### 内聚性

对子程序而言，内聚性（`cohesion`）是指子程序中各种操作之间联系的紧密程度

> 我们的目标是让子程序只做好一件事情，不再做任何其他事情

研究表明，高内聚性带来的是程序的高可靠性

#### 内聚性的种类

* 功能的内聚性
  * 让子程序只执行一项操作

最重要的是功能的内聚性，而编写具有功能内聚性的子程序几乎总是可能的，因此我们把注意力放到上面即可

## 子程序的命名

参见 ……

## 子程序的长度

* 研究表明，可以允许子程序的长度有序地增长到 100~200 行（不算注释行和空行）
  * 也就是，如果子程序超过了200行，就要小心了，没有研究发现它能降低成本或出错率
  * 研究表明，100~200 行的子程序也和短小的子程序一样不易出错
* 更加着重于考虑以下因素：
  * 子程序的内聚性
  * 嵌套的层次
  * 变量的数量
  * 决策的（decision points）的数量
  * 所需注释数量（解释子程序用意）
  * 复杂度相关的其他事项

## 子程序的参数

> 其他参考
> 32.5 节 注释子程序
> 31.7 节 子程序的布局

* 参数的排列顺序：仅作为`输入`的参数 - 会被`修改`的参数 - 仅作为`输出`的参数
  * 暗含了操作顺序，`被修改`参数是指既作为输入又作为输出的参数
  * note: C 函数库中的规则是，将会被修改的参数放在最前面
* 考虑自己创建 `in` 和 `out` 关键字
  * Ada 里面有这两个关键字
  * 如果使用，请保持一致性，至少在整个项目范围都使用
    * 因为不是编程语言内置的，会让阅读者感到生疏
  * 对于仅作为输入的参数而言，使用 `const` 可能更好（假如编程语言自带）
* 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致
  * 一致性！
  * 如 C 语言中的 `strncpy()`  和 `memcpy()` 的参数列表
* ==使用所有的参数==
  * 如果一个参数没有被使用到，那么就把它从子程序的接口中删去
* 把`状态变量`和`指示发生错误的变量`放在参数表的最后面
  * 理由：
    * 只是附属功能
    * 是仅作为输出的参数
* ==子程序里的工作变量应该使用局部变量，不能用子程序的输入参数==
  * 使用局部变量（这点存储空间无关紧要）作为工作变量，将输入值赋给它
  * 在 C++ 中，可以利用 `const` 关键字限定参数，防止修改
  * 好处：强调了数据的来源，避免意外修改参数表中变量的值（因为可能还要用到原来的值）
* ==在接口中对参数的假定特征加以说明==
  * 在子程序内部和调用子程序的地方都进行这样的说明
  * 先写注释来说明假定（而不是写完子程序后再来写注释，会不记得的）
    * 更好的方法是使用`断言`
  * 需要说明的项目
    * 参数的性质：仅作为输入的、要被修改的、仅用于输出的，分别是哪些参数
    * 表示数量的参数，它们的单位（m，km/h 等）
    * 如果没有使用枚举类型，则说明状态码和错误值的含义
    * 所能接受的数值范围
    * 哪些是不该出现的特定数值
* 参数个数限制在 7 个以内
  * 基于心理学的研究
  * 如果参数数量太多，说明子程序间的耦合太紧密
    * 也可以使用合成数据类型，这样多个数据成员就被“打包”在一个参数里了
  * ==如果总是传递相同的数据给多个不同的子程序，则把这些子程序组成一个类，并把这些经常使用的数据用作类的内部数据==
* 考虑对参数采取某种表示输入、修改、输出的命名规则
  * 假如觉得这种区分很重要的话
  * 如 `i_`, `m_`, `o_`
* 传递整个对象还是特定数据？——==为子程序传递维持其接口抽象的变量或对象==
  * 根据情况来决定是传递整个对象还是对象的特定成员
  * 方法：判断子程序接口需要表达的是何种抽象
    * 如果要表达的抽象是：子程序期望那几项特定的数据，只不过它们碰巧来自同一个对象——那么，应该单独传递这几项数据而不是整个对象
      * note：如果有下面这种行为：先创建出一个对象，再将子程序需要的数据填入这个对象，然后传递对象来调用子程序；或者是，调用完子程序后又从对象中取出这些数据——说明你不应该传递整个对象，而是应该只传递特定的数据
      * 因为，==在调用子程序前进行 set up，在调用子程序后进行 take down 的行为，是设计不良的表现==
    * 如果表达的抽象是：想一直拥有某个特定的对象，而子程序要对这个对象执行一系列的操作——那么就应该传递整个对象
      * note：如果需要经常修改子程序的参数表，而每次修改的参数又都是来自同一个对象——那就说明应该传递整个对象
* 使用具名参数
  * todo
  * 这个 swift 里有
  * 当同类参数数量过多，会有帮助；避免放错位置
* 确保实际参数和形式参数相匹配
  * 如类型匹配

## 使用函数时要考虑的问题

`函数`是有返回值的子程序，`过程`是没有返回值的子程序

那些返回值是 void 的 “函数”，在语义上实际就是过程

### 什么时候使用函数，什么时候使用过程

？？todo

这个不太理解书中要表达的意思

> 语言纯化论者认为，函数永远应该以它所返回的值命名，如 sin()，CustomerID()，ScreenHeight()

### 设置函数的返回值

* 找脑海中执行每一条路径，确保所有可能情况下，函数都具有返回值
  * 在函数开头就用一个 default 值来初始化返回值，是一个保险的做法
* 不要返回局部数据的引用或指针
  * 因为子程序结束，局部数据出了作用域，相关指针也就失效
  * 如果一个`对象`需要返回其内部的数据信息，则应该把这些数据保存为`类的数据成员`，然后提供访问器子程序（`get()`）

