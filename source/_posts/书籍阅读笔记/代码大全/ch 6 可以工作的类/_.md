# 类

`类` 是一组数据和子程序构成的集合，这些数据和子程序共同拥有一组内聚的、明确定义的职责。类也可以只是由一组子程序构成的集合，这些子程序提供一组内聚的服务。

> 考虑类的一种方式，就是把它看成是：抽象数据类型+继承+多态

## 类的基础：抽象数据类型

> 要想理解面向对象编程，首先要理解 `ADT`

抽象数据类型（ADT）是指一些**数据**以及对这些数据所进行的**操作**的集合。

这些操作：

* 既向程序的其余部分`描述`了这些数据是什么样的
* 也允许程序的其余部分`改变`这些数据




不使用 ADT，可能会需要调用方的代码直接控制数据成员



todo

todo

# 良好的类接口

类的接口指的是：类所具有的公用（public）子程序所构成的集合

类的接口为隐藏在其后的具体实现提供了一种抽象（也就是对具体实现的一种“总结”说明，不需去关心具体的细节）

## 好的抽象

> 关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入理解类的设计

> ==`抽象`是一种以简化的方式来看待复杂操作的能力==
>
> note：这里的抽象是中文里的动词，而不是形容词。
> "从众多的具体事物中，抽取共同的、本质的属性，舍弃个别的、非本质的属性，从而形成概念。"
>
> abstract(v.) 的同义词有：summarize、cut down、compress、extract、separate

类的接口为隐藏在其后的具体实现提供了一种抽象（也就是对具体实现的一种“总结”说明）

### 指导建议

#### 保持一致的抽象

* **一个好的接口，应该展现出“一致的抽象层次”**
  * 也就是这一组子程序必须是明显相关的，处理着同类事物，具有强内聚性
  * 可以把类看成是一种用来实现 ADT 的机制——每个类应该实现一个 ADT，并且仅实现这个 ADT
  * 混杂抽象层次的问题
    * 危害：让程序越来越难理解，整个程序逐步堕落直到变得无法维护
    * 例子：有个类接口混合了两个不同层次的抽象——Employee 和 ListContainer
    * 原因：使用了类库“ListContainer”，却没有隐藏这一事实
    * 解决：使用 `private`，将 ListContainer 的实现细节对程序其余部分隐藏
* **不要添加与接口抽象不一致的公用成员**
  * 每次向类的接口中添加子程序，都问问这个子程序是否和现有接口所提供的抽象相一致。如果不一致，就用其他方法修改它
* **保持类数据的内聚性，把不相关的信息转移到其他类中**
  * 例子
    * 如果某个类中一半的子程序使用着其中的一半数据，而另一半子程序则使用着另一半的数据，那么其实你是把两个类混在一起用了，应该拆开它们
* **提防在修改接口时，对接口抽象的“侵蚀”破坏**
  * 有时需要对类进行修改和扩展，却常常会添加一些额外功能，需要注意这些功能是不是适应于原有的类接口（比如是不是仍在同一抽象层次？）

#### 其他

* **一定要理解类所实现的抽象是什么**

  * ？
  * todo - page136

* **提供成对的服务 with their opposites** 

  * 比如说 add 和 remove 就是一对相反的操作
  * 检查每个公用子程序，看是否需要另一个与其互补的操作。但也不能盲目得去创建相反操作，考虑清楚是否需要它

* **尽可能让接口可编程（programatic），而不是依赖语义**

  * > Make interfaces `programmatic` rather than `semantic` when possible

  * 因为编译器能强制性实现 programatic 的部分，但不能检查由假定组成的语义部分

  * note:  语义部分由“本接口应该如何使用”的假定组成，像这些：“如果 dataMember 的数值……，将会导致……崩溃”

  * 语义接口应该用注释详细说明，但尽量不要让接口去依赖这些说明（因为无法通过编译器强制实施）

  * 想办法将语义接口的内容转换为 programatic 的，如用 assertion

## 良好的封装

`封装`（encapsulation）是比抽象更强的概念，抽象提供了一个可以忽略实现细节的模型来管理复杂度，而封装则**强制阻止你看到细节**——即使你想这么做

> 没有封装时，抽象往往容易被打破
>
> 要么是封装与抽象两者皆有，要么是两者皆失
>
> 如果必须要看到底层实现才能理解发生的事情，那根本算不上抽象 —— P.J Plauger

正是因为封装阻止你看到接口的具体内部实现，你才会在针对接口去调用它们来编程（从而是使用`抽象`去编程；这样，即使当接口的内部实现改变了，程序也不会受到破坏）；如果你利用接口当下内部实现的一些性质去编程，万一有一天它们改变了，你就头疼了！

### 指导建议

todo

# 类内部的设计和实现

### 包含关系（has a）

`包含`（containment）是一个很简单的概念，但它却是面向对象编程中的主力技术。而继承只是因为更加难、更易出错所以才那么多论述，并不是因为比包含更好

**实现“has a”关系**

* 通过包含来实现“has a”关系
  * 在类中添加对应的数据成员来实现这种关系
  * 比如，一个雇员“有一个” name、“有一个” phoneNum、“有一个” taxID，那么可以让 name、phoneNum、taxID 成为 Employee 类的数据成员，来建立这种关系
* 万不得已时才通过 private 继承来实现“has a”关系
  * todo

**数据成员的数量**

* 一个类中的数据成员数量在  $$7\pm2$$ 间
  * 如果超过这个范围，请考虑是否应该分解为几个更小的类
  * 如果数据成员是简单数据类型，可以按上限（即 9个）来衡量
  * 如果数据成员都是复杂的对象，可以按下限（即 5个）来衡量

### 继承关系（is a）

继承（inheritance）是指，一个类~（派生类）~是另一个类~（基类）~的“特化例子”（specialization）

因为继承定义了基类，为两个或以上的派生类提供了**共有元素**，从而避免代码重复，更加精简

todo

todo

> （这一节信息量太大，需要再阅读多几遍，加上实际才能总结）

### 成员函数和数据成员

todo

收获最大的是，demeter 法则（要自己再搜索资料）